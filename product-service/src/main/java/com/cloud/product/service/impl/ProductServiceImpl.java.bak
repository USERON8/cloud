package com.cloud.product.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
// import com.cloud.common.cache.annotation.*;
import com.cloud.product.annotation.*;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import com.cloud.common.domain.dto.product.ProductDTO;
import com.cloud.common.domain.dto.product.ProductPageDTO;
import com.cloud.product.exception.ProductNotFoundException;
import com.cloud.product.exception.ProductStatusException;
import com.cloud.product.exception.ProductServiceException;
import com.cloud.common.domain.dto.product.ProductRequestDTO;
import com.cloud.common.result.PageResult;
import com.cloud.common.utils.BeanCopyUtils;
import com.cloud.product.converter.ProductConverter;
import com.cloud.product.mapper.ProductMapper;
import com.cloud.product.module.entity.Product;
import com.cloud.product.service.ProductService;
import com.cloud.product.vo.ProductVO;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * å•†å“æœåŠ¡å®ç°ç±?
 * å®ç°å•†å“ç›¸å…³çš„ä¸šåŠ¡æ“ä½œï¼Œä½¿ç”¨å¤šçº§ç¼“å­˜æå‡æ€§èƒ½
 * éµå¾ªç”¨æˆ·æœåŠ¡æ ‡å‡†ï¼ŒåŒ…å«äº‹åŠ¡ç®¡ç†å’Œç¼“å­˜ç®¡ç†
 *
 * @author what's up
 * @since 1.0.0
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductServiceImpl extends ServiceImpl<ProductMapper, Product>
        implements ProductService {

    private final ProductConverter productConverter;

    // ================= åŸºç¡€CRUDæ“ä½œ =================

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCachePut(cacheName = "productCache", key = "#result",
            condition = "#result != null",
            expire = 60, timeUnit = TimeUnit.MINUTES)
    public Long createProduct(ProductRequestDTO requestDTO) throws ProductServiceException {
        log.info("åˆ›å»ºå•†å“: {}", requestDTO.getName());

        // è½¬æ¢ä¸ºå®ä½?
        Product product = productConverter.requestDTOToEntity(requestDTO);

        // ä¿å­˜å•†å“
        boolean saved = save(product);
        if (!saved) {
            throw new ProductServiceException("åˆ›å»ºå•†å“å¤±è´¥");
        }

        log.info("å•†å“åˆ›å»ºæˆåŠŸ, ID: {}", product.getId());
        return product.getId();
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id",
                    condition = "#result == true",
                    expire = 60, timeUnit = TimeUnit.MINUTES),
            evict = {
                    @MultiLevelCacheEvict(cacheName = "productListCache", allEntries = true),
                    @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
            }
    )
    public Boolean updateProduct(Long id, ProductRequestDTO requestDTO) throws ProductNotFoundException, ProductServiceException {
        log.info("æ›´æ–°å•†å“: ID={}, Name={}", id, requestDTO.getName());

        // æ£€æŸ¥å•†å“æ˜¯å¦å­˜åœ?
        Product existingProduct = getById(id);
        if (existingProduct == null) {
            throw new RuntimeException("å•†å“ä¸å­˜åœ? " + id);
        }

        // æ›´æ–°å•†å“ä¿¡æ¯
        BeanCopyUtils.copyProperties(requestDTO, existingProduct);
        existingProduct.setId(id);

        boolean updated = updateById(existingProduct);
        if (!updated) {
            throw new RuntimeException("æ›´æ–°å•†å“å¤±è´¥");
        }

        log.info("å•†å“æ›´æ–°æˆåŠŸ: {}", id);
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            evict = {
                    @MultiLevelCacheEvict(cacheName = "productCache", key = "#id"),
                    @MultiLevelCacheEvict(cacheName = "productListCache", allEntries = true),
                    @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
            }
    )
    public Boolean deleteProduct(Long id) throws ProductNotFoundException, ProductServiceException {
        log.info("åˆ é™¤å•†å“: {}", id);

        // æ£€æŸ¥å•†å“æ˜¯å¦å­˜åœ?
        Product product = getById(id);
        if (product == null) {
            throw new RuntimeException("å•†å“ä¸å­˜åœ? " + id);
        }

        boolean deleted = removeById(id);
        if (!deleted) {
            throw new RuntimeException("åˆ é™¤å•†å“å¤±è´¥");
        }

        log.info("å•†å“åˆ é™¤æˆåŠŸ: {}", id);
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCacheEvict(value = {"productCache", "productListCache", "productStatsCache"},
            allEntries = true)
    public Boolean batchDeleteProducts(List<Long> ids) {
        log.info("æ‰¹é‡åˆ é™¤å•†å“: {}", ids);

        if (CollectionUtils.isEmpty(ids)) {
            return true;
        }

        boolean deleted = removeBatchByIds(ids);
        if (!deleted) {
            throw new RuntimeException("æ‰¹é‡åˆ é™¤å•†å“å¤±è´¥");
        }

        log.info("æ‰¹é‡åˆ é™¤å•†å“æˆåŠŸ, æ•°é‡: {}", ids.size());
        return true;
    }

    // ================= æŸ¥è¯¢æ“ä½œ =================

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productCache", key = "#id",
            condition = "#id != null",
            expire = 60, timeUnit = TimeUnit.MINUTES)
    public ProductVO getProductById(Long id) throws ProductNotFoundException {
        log.debug("è·å–å•†å“è¯¦æƒ…: {}", id);

        Product product = getById(id);
        if (product == null) {
            throw new ProductNotFoundException(id);
        }

        return productConverter.toVO(product);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ProductVO> getProductsByIds(List<Long> ids) {
        log.debug("æ‰¹é‡è·å–å•†å“: {}", ids);

        if (CollectionUtils.isEmpty(ids)) {
            return new ArrayList<>();
        }

        List<Product> products = listByIds(ids);
        return productConverter.toVOList(products);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productListCache",
            key = "'page:' + #pageDTO.pageNum + ':' + #pageDTO.pageSize + ':' + (#pageDTO.name ?: 'null') + ':' + (#pageDTO.status ?: 'null')",
            expire = 30, timeUnit = TimeUnit.MINUTES)
    public PageResult<ProductVO> getProductsPage(ProductPageDTO pageDTO) {
        log.debug("åˆ†é¡µæŸ¥è¯¢å•†å“: {}", pageDTO);

        Page<Product> page = new Page<>(pageDTO.getPageNum(), pageDTO.getPageSize());
        LambdaQueryWrapper<Product> queryWrapper = buildQueryWrapper(pageDTO);

        Page<Product> productPage = page(page, queryWrapper);
        List<ProductVO> productVOs = productConverter.toVOList(productPage.getRecords());

        return PageResult.of(productVOs, productPage.getTotal(), pageDTO.getPageNum(), pageDTO.getPageSize());
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productListCache",
            key = "'category:' + #categoryId + ':' + (#status ?: 'null')",
            expire = 45, timeUnit = TimeUnit.MINUTES)
    public List<ProductVO> getProductsByCategoryId(Long categoryId, Integer status) {
        log.debug("æ ¹æ®åˆ†ç±»æŸ¥è¯¢å•†å“: categoryId={}, status={}", categoryId, status);

        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getCategoryId, categoryId);
        if (status != null) {
            queryWrapper.eq(Product::getStatus, status);
        }
        queryWrapper.orderByDesc(Product::getCreateTime);

        List<Product> products = list(queryWrapper);
        return productConverter.toVOList(products);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productListCache",
            key = "'brand:' + #brandId + ':' + (#status ?: 'null')",
            expire = 45, timeUnit = TimeUnit.MINUTES)
    public List<ProductVO> getProductsByBrandId(Long brandId, Integer status) {
        log.debug("æ ¹æ®å“ç‰ŒæŸ¥è¯¢å•†å“: brandId={}, status={}", brandId, status);

        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getBrandId, brandId);
        if (status != null) {
            queryWrapper.eq(Product::getStatus, status);
        }
        queryWrapper.orderByDesc(Product::getCreateTime);

        List<Product> products = list(queryWrapper);
        return productConverter.toVOList(products);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productListCache",
            key = "'search:' + #name + ':' + (#status ?: 'null')",
            expire = 30, timeUnit = TimeUnit.MINUTES)
    public List<ProductVO> searchProductsByName(String name, Integer status) {
        log.debug("æœç´¢å•†å“: name={}, status={}", name, status);

        if (!StringUtils.hasText(name)) {
            return new ArrayList<>();
        }

        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.like(Product::getName, name);
        if (status != null) {
            queryWrapper.eq(Product::getStatus, status);
        }
        queryWrapper.orderByDesc(Product::getCreateTime);

        List<Product> products = list(queryWrapper);
        return productConverter.toVOList(products);
    }

    // ================= çŠ¶æ€ç®¡ç?=================

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id"),
            evict = {
                    @MultiLevelCacheEvict(cacheName = "productListCache", allEntries = true),
                    @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
            }
    )
    public Boolean enableProduct(Long id) throws ProductNotFoundException, ProductStatusException, ProductServiceException {
        return updateProductStatus(id, 1, "ä¸Šæ¶");
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id"),
            evict = {
                    @MultiLevelCacheEvict(cacheName = "productListCache", allEntries = true),
                    @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
            }
    )
    public Boolean disableProduct(Long id) throws ProductNotFoundException, ProductStatusException, ProductServiceException {
        return updateProductStatus(id, 0, "ä¸‹æ¶");
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCacheEvict(value = {"productCache", "productListCache", "productStatsCache"},
            allEntries = true)
    public Boolean batchEnableProducts(List<Long> ids) {
        return batchUpdateProductStatus(ids, 1, "æ‰¹é‡ä¸Šæ¶");
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCacheEvict(value = {"productCache", "productListCache", "productStatsCache"},
            allEntries = true)
    public Boolean batchDisableProducts(List<Long> ids) {
        return batchUpdateProductStatus(ids, 0, "æ‰¹é‡ä¸‹æ¶");
    }

    // ================= åº“å­˜ç®¡ç† =================

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id"),
            evict = @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
    )
    public Boolean updateStock(Long id, Integer stock) {
        log.info("æ›´æ–°å•†å“åº“å­˜: ID={}, Stock={}", id, stock);

        if (stock < 0) {
            throw new RuntimeException("åº“å­˜æ•°é‡ä¸èƒ½ä¸ºè´Ÿæ•?);
        }

        LambdaUpdateWrapper<Product> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(Product::getId, id).set(Product::getStock, stock);

        boolean updated = update(updateWrapper);
        if (!updated) {
            throw new RuntimeException("æ›´æ–°åº“å­˜å¤±è´¥");
        }

        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id"),
            evict = @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
    )
    public Boolean increaseStock(Long id, Integer quantity) {
        log.info("å¢åŠ å•†å“åº“å­˜: ID={}, Quantity={}", id, quantity);

        if (quantity <= 0) {
            throw new RuntimeException("å¢åŠ æ•°é‡å¿…é¡»å¤§äº0");
        }

        LambdaUpdateWrapper<Product> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(Product::getId, id)
                .setSql("stock = stock + " + quantity);

        boolean updated = update(updateWrapper);
        if (!updated) {
            throw new RuntimeException("å¢åŠ åº“å­˜å¤±è´¥");
        }

        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    @MultiLevelCaching(
            put = @MultiLevelCachePut(cacheName = "productCache", key = "#id"),
            evict = @MultiLevelCacheEvict(cacheName = "productStatsCache", allEntries = true)
    )
    public Boolean decreaseStock(Long id, Integer quantity) {
        log.info("å‡å°‘å•†å“åº“å­˜: ID={}, Quantity={}", id, quantity);

        if (quantity <= 0) {
            throw new RuntimeException("å‡å°‘æ•°é‡å¿…é¡»å¤§äº0");
        }

        LambdaUpdateWrapper<Product> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(Product::getId, id)
                .ge(Product::getStock, quantity) // ä¿è¯åº“å­˜å……è¶³
                .setSql("stock = stock - " + quantity);

        boolean updated = update(updateWrapper);
        if (!updated) {
            throw new RuntimeException("åº“å­˜ä¸è¶³æˆ–å‡å°‘å¤±è´?);
        }

        return true;
    }

    @Override
    @Transactional(readOnly = true)
    public Boolean checkStock(Long id, Integer quantity) {
        log.debug("æ£€æŸ¥å•†å“åº“å­? ID={}, Quantity={}", id, quantity);

        if (quantity <= 0) {
            return true;
        }

        Product product = getById(id);
        if (product == null) {
            return false;
        }

        return product.getStock() >= quantity;
    }

    // ================= ç»Ÿè®¡åˆ†æ =================

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productStatsCache", key = "'total'",
            expire = 120, timeUnit = TimeUnit.MINUTES)
    public Long getTotalProductCount() {
        return count();
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productStatsCache", key = "'enabled'",
            expire = 120, timeUnit = TimeUnit.MINUTES)
    public Long getEnabledProductCount() {
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getStatus, 1);
        return count(queryWrapper);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productStatsCache", key = "'disabled'",
            expire = 120, timeUnit = TimeUnit.MINUTES)
    public Long getDisabledProductCount() {
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getStatus, 0);
        return count(queryWrapper);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productStatsCache", key = "'category:' + #categoryId",
            expire = 120, timeUnit = TimeUnit.MINUTES)
    public Long getProductCountByCategoryId(Long categoryId) {
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getCategoryId, categoryId);
        return count(queryWrapper);
    }

    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productStatsCache", key = "'brand:' + #brandId",
            expire = 120, timeUnit = TimeUnit.MINUTES)
    public Long getProductCountByBrandId(Long brandId) {
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getBrandId, brandId);
        return count(queryWrapper);
    }

    // ================= ç¼“å­˜ç®¡ç† =================

    @Override
    @MultiLevelCacheEvict(cacheName = "productCache", key = "#id")
    public void evictProductCache(Long id) {
        log.info("æ¸…é™¤å•†å“ç¼“å­˜: {}", id);
    }

    @Override
    @MultiLevelCacheEvict(value = {"productCache", "productListCache", "productStatsCache"},
            allEntries = true)
    public void evictAllProductCache() {
        log.info("æ¸…é™¤æ‰€æœ‰å•†å“ç¼“å­?);
    }

    @Override
    public void warmupProductCache(List<Long> ids) {
        log.info("é¢„çƒ­å•†å“ç¼“å­˜: {}", ids);

        if (CollectionUtils.isEmpty(ids)) {
            return;
        }

        // é¢„çƒ­å•†å“è¯¦æƒ…ç¼“å­˜
        ids.forEach(this::getProductById);

        log.info("å•†å“ç¼“å­˜é¢„çƒ­å®Œæˆ, æ•°é‡: {}", ids.size());
    }
    
    // ================= Feignå®¢æˆ·ç«¯æ¥å£æ–¹æ³•å®ç?=================
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public ProductDTO createProductForFeign(ProductDTO productDTO) {
        log.info("åˆ›å»ºå•†å“ï¼ˆFeignï¼? {}", productDTO.getName());
        
        // è½¬æ¢ä¸ºRequestDTO
        ProductRequestDTO requestDTO = productConverter.dtoToRequestDTO(productDTO);
        Long productId = createProduct(requestDTO);
        
        // è¿”å›åˆ›å»ºçš„å•†å“ä¿¡æ?
        ProductVO productVO = getProductById(productId);
        return productConverter.voToDTO(productVO);
    }
    
    @Override
    @Transactional(readOnly = true)
    public ProductDTO getProductByIdForFeign(Long id) {
        log.debug("è·å–å•†å“è¯¦æƒ…ï¼ˆFeignï¼? {}", id);
        
        ProductVO productVO = getProductById(id);
        if (productVO == null) {
            return null;
        }
        
        return productConverter.voToDTO(productVO);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public ProductDTO updateProductForFeign(Long id, ProductDTO productDTO) {
        log.info("æ›´æ–°å•†å“ï¼ˆFeignï¼? ID={}, Name={}", id, productDTO.getName());
        
        // è½¬æ¢ä¸ºRequestDTO
        ProductRequestDTO requestDTO = productConverter.dtoToRequestDTO(productDTO);
        Boolean success = updateProduct(id, requestDTO);
        
        if (success) {
            ProductVO productVO = getProductById(id);
            return productConverter.voToDTO(productVO);
        }
        
        return null;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<ProductDTO> getAllProducts() {
        log.debug("è·å–æ‰€æœ‰å•†å“ï¼ˆFeignï¼?);
        
        List<Product> products = list();
        List<ProductVO> productVOs = productConverter.toVOList(products);
        return productConverter.voListToDTOList(productVOs);
    }
    
    @Override
    @Transactional(readOnly = true)
    @MultiLevelCacheable(cacheName = "productListCache",
            key = "'shop:' + #shopId",
            expire = 45, timeUnit = TimeUnit.MINUTES)
    public List<ProductDTO> getProductsByShopId(Long shopId) {
        log.debug("æ ¹æ®åº—é“ºIDè·å–å•†å“åˆ—è¡¨ï¼ˆFeignï¼? {}", shopId);
        
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Product::getShopId, shopId)
                .eq(Product::getStatus, 1) // åªè·å–ä¸Šæ¶çš„å•†å“
                .orderByDesc(Product::getCreateTime);
        
        List<Product> products = list(queryWrapper);
        List<ProductVO> productVOs = productConverter.toVOList(products);
        return productConverter.voListToDTOList(productVOs);
    }

    // ================= ç§æœ‰è¾…åŠ©æ–¹æ³• =================

    /**
     * æ„å»ºæŸ¥è¯¢æ¡ä»¶
     */
    private LambdaQueryWrapper<Product> buildQueryWrapper(ProductPageDTO pageDTO) {
        LambdaQueryWrapper<Product> queryWrapper = new LambdaQueryWrapper<>();

        // å•†å“åç§°æ¨¡ç³ŠæŸ¥è¯¢
        if (StringUtils.hasText(pageDTO.getName())) {
            queryWrapper.like(Product::getName, pageDTO.getName());
        }

        // å•†å“çŠ¶æ€?
        if (pageDTO.getStatus() != null) {
            queryWrapper.eq(Product::getStatus, pageDTO.getStatus());
        }

        // åˆ†ç±»ID
        if (pageDTO.getCategoryId() != null) {
            queryWrapper.eq(Product::getCategoryId, pageDTO.getCategoryId());
        }

        // åˆ†ç±»åç§°
        if (StringUtils.hasText(pageDTO.getCategoryName())) {
            queryWrapper.like(Product::getCategoryName, pageDTO.getCategoryName());
        }

        // å“ç‰ŒID
        if (pageDTO.getBrandId() != null) {
            queryWrapper.eq(Product::getBrandId, pageDTO.getBrandId());
        }

        // å“ç‰Œåç§°
        if (StringUtils.hasText(pageDTO.getBrandName())) {
            queryWrapper.like(Product::getBrandName, pageDTO.getBrandName());
        }

        // ä»·æ ¼èŒƒå›´
        if (pageDTO.getMinPrice() != null) {
            queryWrapper.ge(Product::getPrice, pageDTO.getMinPrice());
        }
        if (pageDTO.getMaxPrice() != null) {
            queryWrapper.le(Product::getPrice, pageDTO.getMaxPrice());
        }

        // åº“å­˜èŒƒå›´
        if (pageDTO.getMinStock() != null) {
            queryWrapper.ge(Product::getStock, pageDTO.getMinStock());
        }
        if (pageDTO.getMaxStock() != null) {
            queryWrapper.le(Product::getStock, pageDTO.getMaxStock());
        }

        // æ’åº
        applySorting(queryWrapper, pageDTO);

        return queryWrapper;
    }

    /**
     * åº”ç”¨æ’åºæ¡ä»¶
     */
    private void applySorting(LambdaQueryWrapper<Product> queryWrapper, ProductPageDTO pageDTO) {
        // ä»·æ ¼æ’åº
        if ("ASC".equalsIgnoreCase(pageDTO.getPriceSort())) {
            queryWrapper.orderByAsc(Product::getPrice);
        } else if ("DESC".equalsIgnoreCase(pageDTO.getPriceSort())) {
            queryWrapper.orderByDesc(Product::getPrice);
        }

        // åº“å­˜æ’åº
        if ("ASC".equalsIgnoreCase(pageDTO.getStockSort())) {
            queryWrapper.orderByAsc(Product::getStock);
        } else if ("DESC".equalsIgnoreCase(pageDTO.getStockSort())) {
            queryWrapper.orderByDesc(Product::getStock);
        }

        // åˆ›å»ºæ—¶é—´æ’åº
        if ("ASC".equalsIgnoreCase(pageDTO.getCreateTimeSort())) {
            queryWrapper.orderByAsc(Product::getCreateTime);
        } else if ("DESC".equalsIgnoreCase(pageDTO.getCreateTimeSort())) {
            queryWrapper.orderByDesc(Product::getCreateTime);
        }

        // æ›´æ–°æ—¶é—´æ’åº
        if ("ASC".equalsIgnoreCase(pageDTO.getUpdateTimeSort())) {
            queryWrapper.orderByAsc(Product::getUpdateTime);
        } else if ("DESC".equalsIgnoreCase(pageDTO.getUpdateTimeSort())) {
            queryWrapper.orderByDesc(Product::getUpdateTime);
        }

        // é»˜è®¤æ’åºï¼ˆå¦‚æœæ²¡æœ‰æŒ‡å®šä»»ä½•æ’åºï¼‰
        if (!StringUtils.hasText(pageDTO.getPriceSort()) &&
                !StringUtils.hasText(pageDTO.getStockSort()) &&
                !StringUtils.hasText(pageDTO.getCreateTimeSort()) &&
                !StringUtils.hasText(pageDTO.getUpdateTimeSort())) {
            queryWrapper.orderByDesc(Product::getCreateTime);
        }
    }

    /**
     * æ›´æ–°å•†å“çŠ¶æ€?
     */
    private Boolean updateProductStatus(Long id, Integer status, String operation) {
        log.info("{}å•†å“: {}", operation, id);

        // æ£€æŸ¥å•†å“æ˜¯å¦å­˜åœ?
        Product product = getById(id);
        if (product == null) {
            throw new RuntimeException("å•†å“ä¸å­˜åœ? " + id);
        }

        // æ£€æŸ¥çŠ¶æ€æ˜¯å¦å·²ç»æ˜¯ç›®æ ‡çŠ¶æ€?
        if (product.getStatus().equals(status)) {
            log.warn("å•†å“å·²ç»æ˜¯{}çŠ¶æ€? {}", operation, id);
            return true;
        }

        LambdaUpdateWrapper<Product> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(Product::getId, id).set(Product::getStatus, status);

        boolean updated = update(updateWrapper);
        if (!updated) {
            throw new RuntimeException(operation + "å•†å“å¤±è´¥");
        }

        log.info("{}å•†å“æˆåŠŸ: {}", operation, id);
        return true;
    }

    /**
     * æ‰¹é‡æ›´æ–°å•†å“çŠ¶æ€?
     */
    private Boolean batchUpdateProductStatus(List<Long> ids, Integer status, String operation) {
        log.info("{}, æ•°é‡: {}", operation, ids.size());

        if (CollectionUtils.isEmpty(ids)) {
            return true;
        }

        LambdaUpdateWrapper<Product> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.in(Product::getId, ids).set(Product::getStatus, status);

        boolean updated = update(updateWrapper);
        if (!updated) {
            throw new RuntimeException(operation + "å¤±è´¥");
        }

        log.info("{}æˆåŠŸ, æ•°é‡: {}", operation, ids.size());
        return true;
    }
}
