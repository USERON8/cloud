package com.cloud.payment.service.impl;

import com.cloud.common.domain.dto.payment.PaymentDTO;
import com.cloud.common.exception.EntityNotFoundException;
import com.cloud.common.lock.DistributedLockTemplate;
import com.cloud.payment.converter.PaymentConverter;
import com.cloud.payment.mapper.PaymentMapper;
import com.cloud.payment.module.dto.PaymentOperationResult;
import com.cloud.payment.module.entity.Payment;
import com.cloud.payment.service.PaymentLockService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.List;

/**
 * ÊîØ‰ªòÂπÇÁ≠âÈîÅÊúçÂä°ÂÆûÁé∞Á±ª
 * Âü∫‰∫éÂàÜÂ∏ÉÂºèÈîÅÂÆûÁé∞ÁöÑÊîØ‰ªòÂπÇÁ≠âÊìç‰ΩúÊúçÂä°ÔºåÁ°Æ‰øùÂπ∂ÂèëÂÆâÂÖ®
 *
 * @author what's up
 * @date 2025-01-15
 * @since 1.0.0
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class PaymentLockServiceImpl implements PaymentLockService {

    /**
     * ÈîÅË∂ÖÊó∂Êó∂Èó¥ÔºàÁßíÔºâ
     */
    private static final Duration LOCK_TIMEOUT = Duration.ofSeconds(15);
    /**
     * ÈîÅÁ≠âÂæÖÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ
     */
    private static final Duration LOCK_WAIT_TIME = Duration.ofMillis(1000);
    private final PaymentMapper paymentMapper;
    private final PaymentConverter paymentConverter;
    private final DistributedLockTemplate lockTemplate;

    @Override
    @Transactional
    public PaymentOperationResult safeCreatePayment(Long orderId, Long userId, BigDecimal amount,
                                                    Integer channel, String traceId,
                                                    Long operatorId, String remark) {
        validateCreateParameters(orderId, userId, amount, channel, traceId, operatorId);

        String lockKey = buildPaymentCreateLockKey(traceId);
        long startTime = System.currentTimeMillis();

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            long lockWaitTime = System.currentTimeMillis() - startTime;

            try {
                // ÂπÇÁ≠âÊÄßÊ£ÄÊü• - Ê†πÊçÆtraceIdÊü•ËØ¢ÊòØÂê¶Â∑≤Â≠òÂú®
                Payment existingPayment = paymentMapper.selectByTraceId(traceId);
                if (existingPayment != null) {
                    log.info("üîÑ Ê£ÄÊµãÂà∞ÂπÇÁ≠âÈáçÂ§çËØ∑Ê±Ç - TraceId: {}, ÊîØ‰ªòID: {}", traceId, existingPayment.getId());
                    return PaymentOperationResult.idempotentDuplicate(
                            PaymentOperationResult.OperationType.CREATE_PAYMENT,
                            existingPayment.getId(),
                            existingPayment.getOrderId(),
                            existingPayment.getUserId(),
                            existingPayment.getAmount(),
                            existingPayment.getStatus(),
                            existingPayment.getTransactionId(),
                            traceId,
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                // ÊâßË°åÂπÇÁ≠âÂàõÂª∫
                int affectedRows = paymentMapper.insertPaymentIdempotent(orderId, userId, amount, channel, traceId);

                if (affectedRows == 0) {
                    // ÂèØËÉΩÊòØÂπ∂ÂèëÊÉÖÂÜµ‰∏ãÂÖ∂‰ªñÁ∫øÁ®ãÂ∑≤ÂàõÂª∫ÔºåÂÜçÊ¨°Êü•ËØ¢
                    Payment concurrentPayment = paymentMapper.selectByTraceId(traceId);
                    if (concurrentPayment != null) {
                        log.info("üîÑ Âπ∂ÂèëÂàõÂª∫Ê£ÄÊµãÂà∞ÈáçÂ§ç - TraceId: {}, ÊîØ‰ªòID: {}", traceId, concurrentPayment.getId());
                        return PaymentOperationResult.idempotentDuplicate(
                                PaymentOperationResult.OperationType.CREATE_PAYMENT,
                                concurrentPayment.getId(),
                                concurrentPayment.getOrderId(),
                                concurrentPayment.getUserId(),
                                concurrentPayment.getAmount(),
                                concurrentPayment.getStatus(),
                                concurrentPayment.getTransactionId(),
                                traceId,
                                operatorId
                        ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                    }

                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.CREATE_PAYMENT,
                            null, orderId,
                            PaymentOperationResult.ErrorCode.CONCURRENT_UPDATE_FAILED,
                            "ÊîØ‰ªòËÆ∞ÂΩïÂàõÂª∫Â§±Ë¥•",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                // Êü•ËØ¢ÂàõÂª∫ÁöÑÊîØ‰ªòËÆ∞ÂΩï
                Payment createdPayment = paymentMapper.selectByTraceId(traceId);
                if (createdPayment == null) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.CREATE_PAYMENT,
                            null, orderId,
                            PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                            "ÊîØ‰ªòËÆ∞ÂΩïÂàõÂª∫ÂêéÊü•ËØ¢Â§±Ë¥•",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                log.info("‚úÖ ÊîØ‰ªòËÆ∞ÂΩïÂàõÂª∫ÊàêÂäü - ÊîØ‰ªòID: {}, ËÆ¢ÂçïID: {}, ÈáëÈ¢ù: {}, TraceId: {}",
                        createdPayment.getId(), orderId, amount, traceId);

                return PaymentOperationResult.success(
                        PaymentOperationResult.OperationType.CREATE_PAYMENT,
                        createdPayment.getId(),
                        orderId,
                        userId,
                        amount,
                        null,
                        PaymentOperationResult.PaymentStatus.PENDING,
                        null,
                        traceId,
                        operatorId,
                        remark
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);

            } catch (Exception e) {
                log.error("‚ùå ÊîØ‰ªòËÆ∞ÂΩïÂàõÂª∫ÂºÇÂ∏∏ - ËÆ¢ÂçïID: {}, TraceId: {}", orderId, traceId, e);
                return PaymentOperationResult.failure(
                        PaymentOperationResult.OperationType.CREATE_PAYMENT,
                        null, orderId,
                        PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                        "Á≥ªÁªüÂºÇÂ∏∏: " + e.getMessage(),
                        operatorId
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
            }
        });
    }

    @Override
    @Transactional
    public PaymentOperationResult safePaymentSuccess(Long paymentId, String transactionId,
                                                     Long operatorId, String remark) {
        validateParameters(paymentId, operatorId);
        if (!StringUtils.hasText(transactionId)) {
            throw new IllegalArgumentException("Á¨¨‰∏âÊñπÊµÅÊ∞¥Âè∑‰∏çËÉΩ‰∏∫Á©∫");
        }

        String lockKey = buildPaymentLockKey(paymentId);
        long startTime = System.currentTimeMillis();

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            long lockWaitTime = System.currentTimeMillis() - startTime;

            try {
                // Êü•ËØ¢ÂΩìÂâçÊîØ‰ªòÁä∂ÊÄÅ
                Payment payment = paymentMapper.selectByIdForUpdate(paymentId);
                if (payment == null) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.PAYMENT_SUCCESS,
                            paymentId, null,
                            PaymentOperationResult.ErrorCode.PAYMENT_NOT_FOUND,
                            "ÊîØ‰ªòËÆ∞ÂΩï‰∏çÂ≠òÂú®",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                Integer beforeStatus = payment.getStatus();

                // ÊâßË°åÊù°‰ª∂Áä∂ÊÄÅÊõ¥Êñ∞
                int affectedRows = paymentMapper.updateStatusToSuccess(paymentId, transactionId);

                if (affectedRows == 0) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.PAYMENT_SUCCESS,
                            paymentId, payment.getOrderId(),
                            PaymentOperationResult.ErrorCode.INVALID_STATUS_TRANSITION,
                            String.format("ÊîØ‰ªòÁä∂ÊÄÅ‰∏çÂÖÅËÆ∏ÊàêÂäüÔºåÂΩìÂâçÁä∂ÊÄÅ: %s", getStatusName(beforeStatus)),
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                log.info("‚úÖ ÊîØ‰ªòÊàêÂäüÂ§ÑÁêÜÂÆåÊàê - ÊîØ‰ªòID: {}, ËÆ¢ÂçïID: {}, Áä∂ÊÄÅÂèòÂåñ: {} -> {}, ÊµÅÊ∞¥Âè∑: {}",
                        paymentId, payment.getOrderId(), getStatusName(beforeStatus),
                        getStatusName(PaymentOperationResult.PaymentStatus.SUCCESS), transactionId);

                return PaymentOperationResult.success(
                        PaymentOperationResult.OperationType.PAYMENT_SUCCESS,
                        paymentId,
                        payment.getOrderId(),
                        payment.getUserId(),
                        payment.getAmount(),
                        beforeStatus,
                        PaymentOperationResult.PaymentStatus.SUCCESS,
                        transactionId,
                        payment.getTraceId(),
                        operatorId,
                        remark
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);

            } catch (Exception e) {
                log.error("‚ùå ÊîØ‰ªòÊàêÂäüÂ§ÑÁêÜÂºÇÂ∏∏ - ÊîØ‰ªòID: {}", paymentId, e);
                return PaymentOperationResult.failure(
                        PaymentOperationResult.OperationType.PAYMENT_SUCCESS,
                        paymentId, null,
                        PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                        "Á≥ªÁªüÂºÇÂ∏∏: " + e.getMessage(),
                        operatorId
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
            }
        });
    }

    @Override
    @Transactional
    public PaymentOperationResult safePaymentFailed(Long paymentId, String failureReason,
                                                    Long operatorId, String remark) {
        validateParameters(paymentId, operatorId);
        if (!StringUtils.hasText(failureReason)) {
            throw new IllegalArgumentException("Â§±Ë¥•ÂéüÂõ†‰∏çËÉΩ‰∏∫Á©∫");
        }

        String lockKey = buildPaymentLockKey(paymentId);
        long startTime = System.currentTimeMillis();

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            long lockWaitTime = System.currentTimeMillis() - startTime;

            try {
                // Êü•ËØ¢ÂΩìÂâçÊîØ‰ªòÁä∂ÊÄÅ
                Payment payment = paymentMapper.selectByIdForUpdate(paymentId);
                if (payment == null) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.PAYMENT_FAILED,
                            paymentId, null,
                            PaymentOperationResult.ErrorCode.PAYMENT_NOT_FOUND,
                            "ÊîØ‰ªòËÆ∞ÂΩï‰∏çÂ≠òÂú®",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                Integer beforeStatus = payment.getStatus();

                // ÊâßË°åÊù°‰ª∂Áä∂ÊÄÅÊõ¥Êñ∞
                int affectedRows = paymentMapper.updateStatusToFailed(paymentId, failureReason);

                if (affectedRows == 0) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.PAYMENT_FAILED,
                            paymentId, payment.getOrderId(),
                            PaymentOperationResult.ErrorCode.INVALID_STATUS_TRANSITION,
                            String.format("ÊîØ‰ªòÁä∂ÊÄÅ‰∏çÂÖÅËÆ∏Â§±Ë¥•ÔºåÂΩìÂâçÁä∂ÊÄÅ: %s", getStatusName(beforeStatus)),
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                log.info("‚úÖ ÊîØ‰ªòÂ§±Ë¥•Â§ÑÁêÜÂÆåÊàê - ÊîØ‰ªòID: {}, ËÆ¢ÂçïID: {}, Áä∂ÊÄÅÂèòÂåñ: {} -> {}, Â§±Ë¥•ÂéüÂõ†: {}",
                        paymentId, payment.getOrderId(), getStatusName(beforeStatus),
                        getStatusName(PaymentOperationResult.PaymentStatus.FAILED), failureReason);

                return PaymentOperationResult.success(
                        PaymentOperationResult.OperationType.PAYMENT_FAILED,
                        paymentId,
                        payment.getOrderId(),
                        payment.getUserId(),
                        payment.getAmount(),
                        beforeStatus,
                        PaymentOperationResult.PaymentStatus.FAILED,
                        failureReason,
                        payment.getTraceId(),
                        operatorId,
                        remark
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);

            } catch (Exception e) {
                log.error("‚ùå ÊîØ‰ªòÂ§±Ë¥•Â§ÑÁêÜÂºÇÂ∏∏ - ÊîØ‰ªòID: {}", paymentId, e);
                return PaymentOperationResult.failure(
                        PaymentOperationResult.OperationType.PAYMENT_FAILED,
                        paymentId, null,
                        PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                        "Á≥ªÁªüÂºÇÂ∏∏: " + e.getMessage(),
                        operatorId
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
            }
        });
    }

    @Override
    @Transactional
    public PaymentOperationResult safeRefundPayment(Long paymentId, String refundTransactionId,
                                                    Long operatorId, String remark) {
        validateParameters(paymentId, operatorId);
        if (!StringUtils.hasText(refundTransactionId)) {
            throw new IllegalArgumentException("ÈÄÄÊ¨æÊµÅÊ∞¥Âè∑‰∏çËÉΩ‰∏∫Á©∫");
        }

        String lockKey = buildPaymentLockKey(paymentId);
        long startTime = System.currentTimeMillis();

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            long lockWaitTime = System.currentTimeMillis() - startTime;

            try {
                // Êü•ËØ¢ÂΩìÂâçÊîØ‰ªòÁä∂ÊÄÅ
                Payment payment = paymentMapper.selectByIdForUpdate(paymentId);
                if (payment == null) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.REFUND_PAYMENT,
                            paymentId, null,
                            PaymentOperationResult.ErrorCode.PAYMENT_NOT_FOUND,
                            "ÊîØ‰ªòËÆ∞ÂΩï‰∏çÂ≠òÂú®",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                Integer beforeStatus = payment.getStatus();

                // ÊâßË°åÊù°‰ª∂Áä∂ÊÄÅÊõ¥Êñ∞
                int affectedRows = paymentMapper.updateStatusToRefunded(paymentId, refundTransactionId);

                if (affectedRows == 0) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.REFUND_PAYMENT,
                            paymentId, payment.getOrderId(),
                            PaymentOperationResult.ErrorCode.INVALID_STATUS_TRANSITION,
                            String.format("ÊîØ‰ªòÁä∂ÊÄÅ‰∏çÂÖÅËÆ∏ÈÄÄÊ¨æÔºåÂΩìÂâçÁä∂ÊÄÅ: %s", getStatusName(beforeStatus)),
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                log.info("‚úÖ ÊîØ‰ªòÈÄÄÊ¨æÂ§ÑÁêÜÂÆåÊàê - ÊîØ‰ªòID: {}, ËÆ¢ÂçïID: {}, Áä∂ÊÄÅÂèòÂåñ: {} -> {}, ÈÄÄÊ¨æÊµÅÊ∞¥Âè∑: {}",
                        paymentId, payment.getOrderId(), getStatusName(beforeStatus),
                        getStatusName(PaymentOperationResult.PaymentStatus.REFUNDED), refundTransactionId);

                return PaymentOperationResult.success(
                        PaymentOperationResult.OperationType.REFUND_PAYMENT,
                        paymentId,
                        payment.getOrderId(),
                        payment.getUserId(),
                        payment.getAmount(),
                        beforeStatus,
                        PaymentOperationResult.PaymentStatus.REFUNDED,
                        refundTransactionId,
                        payment.getTraceId(),
                        operatorId,
                        remark
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);

            } catch (Exception e) {
                log.error("‚ùå ÊîØ‰ªòÈÄÄÊ¨æÂ§ÑÁêÜÂºÇÂ∏∏ - ÊîØ‰ªòID: {}", paymentId, e);
                return PaymentOperationResult.failure(
                        PaymentOperationResult.OperationType.REFUND_PAYMENT,
                        paymentId, null,
                        PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                        "Á≥ªÁªüÂºÇÂ∏∏: " + e.getMessage(),
                        operatorId
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
            }
        });
    }

    @Override
    @Transactional(readOnly = true)
    public PaymentDTO checkIdempotency(String traceId) {
        if (!StringUtils.hasText(traceId)) {
            throw new IllegalArgumentException("Ë∑üË∏™ID‰∏çËÉΩ‰∏∫Á©∫");
        }

        Payment payment = paymentMapper.selectByTraceId(traceId);
        return payment != null ? paymentConverter.toDTO(payment) : null;
    }

    @Override
    @Transactional(readOnly = true)
    public PaymentDTO getPaymentWithLock(Long paymentId) {
        if (paymentId == null) {
            throw new IllegalArgumentException("ÊîØ‰ªòID‰∏çËÉΩ‰∏∫Á©∫");
        }

        String lockKey = buildPaymentLockKey(paymentId);

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            Payment payment = paymentMapper.selectByIdForUpdate(paymentId);
            if (payment == null) {
                throw new EntityNotFoundException("ÊîØ‰ªòËÆ∞ÂΩï‰∏çÂ≠òÂú®ÔºåÊîØ‰ªòID: " + paymentId);
            }
            return paymentConverter.toDTO(payment);
        });
    }

    @Override
    @Transactional(readOnly = true)
    public List<PaymentDTO> batchGetPaymentStatus(List<Long> paymentIds) {
        if (paymentIds == null || paymentIds.isEmpty()) {
            throw new IllegalArgumentException("ÊîØ‰ªòIDÂàóË°®‰∏çËÉΩ‰∏∫Á©∫");
        }

        // ÂØπÊîØ‰ªòIDÊéíÂ∫èÔºåÈÅøÂÖçÊ≠ªÈîÅ
        List<Long> sortedPaymentIds = paymentIds.stream().sorted().toList();
        String lockKey = buildBatchPaymentLockKey(sortedPaymentIds);

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            List<Payment> payments = paymentMapper.selectBatchByIds(sortedPaymentIds);
            return payments.stream()
                    .map(paymentConverter::toDTO)
                    .toList();
        });
    }

    @Override
    @Transactional
    public PaymentOperationResult safeRetryPayment(Long paymentId, String newTransactionId,
                                                   Long operatorId, String remark) {
        validateParameters(paymentId, operatorId);
        if (!StringUtils.hasText(newTransactionId)) {
            throw new IllegalArgumentException("Êñ∞ÁöÑÁ¨¨‰∏âÊñπÊµÅÊ∞¥Âè∑‰∏çËÉΩ‰∏∫Á©∫");
        }

        String lockKey = buildPaymentLockKey(paymentId);
        long startTime = System.currentTimeMillis();

        return lockTemplate.execute(lockKey, LOCK_TIMEOUT, LOCK_WAIT_TIME, () -> {
            long lockWaitTime = System.currentTimeMillis() - startTime;

            try {
                // Êü•ËØ¢ÂΩìÂâçÊîØ‰ªòÁä∂ÊÄÅ
                Payment payment = paymentMapper.selectByIdForUpdate(paymentId);
                if (payment == null) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.RETRY_PAYMENT,
                            paymentId, null,
                            PaymentOperationResult.ErrorCode.PAYMENT_NOT_FOUND,
                            "ÊîØ‰ªòËÆ∞ÂΩï‰∏çÂ≠òÂú®",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                Integer beforeStatus = payment.getStatus();

                // Âè™ÊúâÂ§±Ë¥•Áä∂ÊÄÅÁöÑÊîØ‰ªòÊâçËÉΩÈáçËØï
                if (!PaymentOperationResult.PaymentStatus.FAILED.equals(beforeStatus)) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.RETRY_PAYMENT,
                            paymentId, payment.getOrderId(),
                            PaymentOperationResult.ErrorCode.INVALID_STATUS_TRANSITION,
                            String.format("ÊîØ‰ªòÁä∂ÊÄÅ‰∏çÂÖÅËÆ∏ÈáçËØïÔºåÂΩìÂâçÁä∂ÊÄÅ: %s", getStatusName(beforeStatus)),
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                // ÊâßË°åÈáçËØïÔºàÊõ¥Êñ∞‰∏∫ÊàêÂäüÁä∂ÊÄÅÔºâ
                int affectedRows = paymentMapper.updateStatusToSuccess(paymentId, newTransactionId);

                if (affectedRows == 0) {
                    return PaymentOperationResult.failure(
                            PaymentOperationResult.OperationType.RETRY_PAYMENT,
                            paymentId, payment.getOrderId(),
                            PaymentOperationResult.ErrorCode.CONCURRENT_UPDATE_FAILED,
                            "ÊîØ‰ªòÈáçËØïÊõ¥Êñ∞Â§±Ë¥•",
                            operatorId
                    ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
                }

                log.info("‚úÖ ÊîØ‰ªòÈáçËØïÊàêÂäü - ÊîØ‰ªòID: {}, ËÆ¢ÂçïID: {}, Áä∂ÊÄÅÂèòÂåñ: {} -> {}, Êñ∞ÊµÅÊ∞¥Âè∑: {}",
                        paymentId, payment.getOrderId(), getStatusName(beforeStatus),
                        getStatusName(PaymentOperationResult.PaymentStatus.SUCCESS), newTransactionId);

                return PaymentOperationResult.success(
                        PaymentOperationResult.OperationType.RETRY_PAYMENT,
                        paymentId,
                        payment.getOrderId(),
                        payment.getUserId(),
                        payment.getAmount(),
                        beforeStatus,
                        PaymentOperationResult.PaymentStatus.SUCCESS,
                        newTransactionId,
                        payment.getTraceId(),
                        operatorId,
                        remark
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);

            } catch (Exception e) {
                log.error("‚ùå ÊîØ‰ªòÈáçËØïÂºÇÂ∏∏ - ÊîØ‰ªòID: {}", paymentId, e);
                return PaymentOperationResult.failure(
                        PaymentOperationResult.OperationType.RETRY_PAYMENT,
                        paymentId, null,
                        PaymentOperationResult.ErrorCode.SYSTEM_ERROR,
                        "Á≥ªÁªüÂºÇÂ∏∏: " + e.getMessage(),
                        operatorId
                ).withTiming(System.currentTimeMillis() - startTime, lockWaitTime);
            }
        });
    }

    /**
     * ÂàõÂª∫ÂèÇÊï∞È™åËØÅ
     *
     * @param orderId    ËÆ¢ÂçïID
     * @param userId     Áî®Êà∑ID
     * @param amount     ÊîØ‰ªòÈáëÈ¢ù
     * @param channel    ÊîØ‰ªòÊ∏†ÈÅì
     * @param traceId    Ë∑üË∏™ID
     * @param operatorId Êìç‰Ωú‰∫∫ID
     */
    private void validateCreateParameters(Long orderId, Long userId, BigDecimal amount,
                                          Integer channel, String traceId, Long operatorId) {
        if (orderId == null) {
            throw new IllegalArgumentException("ËÆ¢ÂçïID‰∏çËÉΩ‰∏∫Á©∫");
        }
        if (userId == null) {
            throw new IllegalArgumentException("Áî®Êà∑ID‰∏çËÉΩ‰∏∫Á©∫");
        }
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("ÊîØ‰ªòÈáëÈ¢ùÂøÖÈ°ªÂ§ß‰∫é0");
        }
        if (channel == null) {
            throw new IllegalArgumentException("ÊîØ‰ªòÊ∏†ÈÅì‰∏çËÉΩ‰∏∫Á©∫");
        }
        if (!StringUtils.hasText(traceId)) {
            throw new IllegalArgumentException("Ë∑üË∏™ID‰∏çËÉΩ‰∏∫Á©∫");
        }
        if (operatorId == null) {
            throw new IllegalArgumentException("Êìç‰Ωú‰∫∫ID‰∏çËÉΩ‰∏∫Á©∫");
        }
    }

    /**
     * ÂèÇÊï∞È™åËØÅ
     *
     * @param paymentId  ÊîØ‰ªòID
     * @param operatorId Êìç‰Ωú‰∫∫ID
     */
    private void validateParameters(Long paymentId, Long operatorId) {
        if (paymentId == null) {
            throw new IllegalArgumentException("ÊîØ‰ªòID‰∏çËÉΩ‰∏∫Á©∫");
        }
        if (operatorId == null) {
            throw new IllegalArgumentException("Êìç‰Ωú‰∫∫ID‰∏çËÉΩ‰∏∫Á©∫");
        }
    }

    /**
     * ÊûÑÂª∫ÊîØ‰ªòÂàõÂª∫ÈîÅÈîÆ
     *
     * @param traceId Ë∑üË∏™ID
     * @return ÈîÅÈîÆ
     */
    private String buildPaymentCreateLockKey(String traceId) {
        return "payment:create:" + traceId;
    }

    /**
     * ÊûÑÂª∫ÊîØ‰ªòÈîÅÈîÆ
     *
     * @param paymentId ÊîØ‰ªòID
     * @return ÈîÅÈîÆ
     */
    private String buildPaymentLockKey(Long paymentId) {
        return "payment:status:" + paymentId;
    }

    /**
     * ÊûÑÂª∫ÊâπÈáèÊîØ‰ªòÈîÅÈîÆ
     *
     * @param paymentIds ÊîØ‰ªòIDÂàóË°®ÔºàÂ∑≤ÊéíÂ∫èÔºâ
     * @return ÈîÅÈîÆ
     */
    private String buildBatchPaymentLockKey(List<Long> paymentIds) {
        return "payment:batch:" + String.join(",", paymentIds.stream().map(String::valueOf).toArray(String[]::new));
    }

    /**
     * Ëé∑ÂèñÁä∂ÊÄÅÂêçÁß∞
     *
     * @param status Áä∂ÊÄÅÁ†Å
     * @return Áä∂ÊÄÅÂêçÁß∞
     */
    private String getStatusName(Integer status) {
        if (status == null) {
            return "Êú™Áü•";
        }
        return switch (status) {
            case 0 -> "ÂæÖÊîØ‰ªò";
            case 1 -> "ÊàêÂäü";
            case 2 -> "Â§±Ë¥•";
            case 3 -> "Â∑≤ÈÄÄÊ¨æ";
            default -> "Êú™Áü•Áä∂ÊÄÅ(" + status + ")";
        };
    }
}
